<!DOCTYPE html>
<html lang="en">
<head>
    <title>The Materialize Collapsible Example</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.3/css/materialize.min.css">
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.3/js/materialize.min.js"></script>
</head>
<body>
<div id="nav">
    <div class="navbar-fixed">
        <nav class="red">
            <div class="nav-wrapper container">
                <a href="index.html" class="brand-logo">&nbsp;RCS@SASTRA</a>
                <a href="#" data-activates="mobile-demo" class="button-collapse"><i class="mdi-navigation-menu"></i></a>
                <ul class="right hide-on-med-and-down">
                    <li><a href="projects.html">Projects</a></li>
                    <li><a href="team.html">Our Team</a></li>
                    <li><a href="login.html">Login</a></li>

                </ul>
                <ul id="nav-mobile" class="side-nav">
                    <li><a href="projects.html">Projects</a></li>
                    <li><a href="team.html">Our Team</a></li>
                    <li><a href="login.html">Login</a></li>
                </ul>
            </div>
        </nav>
    </div>
<div class="container">
    <h4 >Fire Fighting Bot</h4>
    <p>Using ATmega2560 and ATmega8</p>
    <p>&nbsp;</p>


    <h5>Done By</h5>
    <hr />
    <p>&nbsp;</p>
    <ul>
        <li>NAVEEN MURALI, IIIYR ECE</li>
        <li>NAVEEN G, IIIYR ECE</li>
        <li>A MUHAMMED SADUL HASAN, IIIYR ECE</li>
        <li>KARTHIK NATARAJAN, IIIYR ECE</li>
    </ul>
    <p>&nbsp;</p>
    <h4><em><strong>ABSTRACT</strong></em></h4>
    <hr />
    <p>&nbsp;</p>
    <p>The aim of this project is to build an automated fire fighting robot that checks for the presence of fires, simulated using leds, in a room and extinguishes them. It must go to four rooms and check for fires in all of them. The robot is to finish the job within given time and space constraints as time plays a major role these days.</p>
    <p>&nbsp;</p>
    <p>The bot checks for fire led, if it detects one then a buzzer is sounded and and a magnet is dropped to extinguish the fire.</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <h5><strong>INTRODUCTION</strong></h5>
    <hr />
    <p>&nbsp;</p>
    <p>Firefighting is the act of extinguishing fires with precedence to saving life, property and nature.</p>
    <p>In urban India, there has been an exponential increase in population density which has resulted in congestion and numerous high-rises. In these cities, the complexity of advanced lifestyle has increased the threat caused by fire hazards. These include weak implementation of development guidelines, old buildings, haphazard constructions, compromised and old electrical infrastructure and so on. Even a minor fire in a single apartment, if not contained in a timely manner, can jeopardize the lives of hundreds of civilians, in and around a building. Such extreme demands of firefighting operations within enclosed spaces stretch the capability of human firefighters, making the job severe and often lethal.</p>
    <p>Automated robotic technology will obviate risking the lives of human firefighters. Furthermore, robotic firefighters will be better than their human counterparts at enduring the toxic environments of combusting material. Due to such reasons, robotic  firefighting technology holds great promise in the future.</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <h5><strong>BUILDING MODULES USED IN THIS PROJECT</strong></h5>
    <hr />
    <p>&nbsp;</p>
    <h5><strong>Electronic Components</strong></h5>
    <h5><strong><em>Microcontroller</em></strong></h5>
    <ul>
        <li>The major controller used is ATmega 2560. It is used as the master controller</li>
        <li>The auxillary controller used is ATmega 8. This is used as the slave controller</li>
    </ul>
    <p>&nbsp;</p>
    <h5><strong><em>Sensors</em></strong></h5>
    <ul>
        <li><em>Sharp IR sensors</em>: these are used for detecting if a door is present and for the wall following algorithm.</li>
        <li><em>White Line Sensor</em>: This is used to make the firebird bot move on a specific line of path. This can be achieved using the highly directional white line sensor. It has a bright red LED, whose light gets reflected back if it is on white surface and gets reflected a little if it is on black line. Hence, localization can be achieved. It is also used to detect the fire led.</li>
        <li>Precision encoder: used to move the bot accurately through given distance or rotate a certain angle.</li>
    </ul>
    <p>&nbsp;</p>
    <h5><strong><em>Indicators</em></strong></h5>
    <ul>
        <li><em>LCD</em>: LCD is used to display any message on the run. It can be used to display any error or exception messages or it can be used to display “successful” message after the task is over</li>
        <li><em>Buzzer</em>: According to our task, buzzer must be on, if the bot finds a black object and also there must be a long buzzer after the task is completely over. For these reasons, a 3 KHz piezo buzzer is used.</li>
    </ul>
    <p><strong> </strong></p>
    <h5><strong>Mechanical Components</strong></h5>
    <p><strong> </strong></p>
    <ul>
        <li>
            <h5><strong><em>Mechanism to drop magnets</em></strong></h5>
        </li>
    </ul>
    <p>The servo motor which will be used in our mechanism to drop magnets and put out fires. For controlling it, we will connect the servo to one of the servo slots provided in the firebird kit. It has an internal power supply which is provided by the “5V servo supply”. For controlling the angle through which it rotates we shall write the appropriate code getting help from the sample code provided.</p>
    <p>&nbsp;</p>
    <ul>
        <li>
            <h5><strong>Diagram of the mechanism</strong></h5>
        </li>
    </ul>
    <p><img class="aligncenter size-full wp-image-701" src="http://www.rcssastra.com/wp-content/uploads/2015/07/fire_1.jpg" alt="fire_1" width="640" height="427" /></p>
    <p>&nbsp;</p>
    <ul>
        <li><strong>Power Management                                          </strong></li>
    </ul>
    <p>For this project, we use Fire Bird V bot. Fire Bird V is powered by 9.6V rechargeable on-board intelligent Nickel Metal Hydride battery pack. The battery should be charged by providing a voltage supply between 12V (fully charged) to 8V (discharged). Avoid using external charger for accidental damage to the batteries and may even cause permanent damage.</p>
    <p>The Fire Bird V Power Management block performs the following functions:</p>
    <ol>
        <li>Battery voltage monitoring and Smart battery charging</li>
        <li>Regulated supply for on-board payload</li>
        <li>Battery current sensing (optional).</li>
    </ol>
    <p>The power is supplied to:</p>
    <ol>
        <li>The processing unit requires 5V, 1A of regulated power supply</li>
        <li>DC motors require 12V and 300mA current. (Provided by motor driver L293D).</li>
        <li>White line sensors and IR proximity sensors are 3.3V sensor.</li>
        <li>Sharp IR sensors require 5V of power supply.</li>
        <li>Servo motor pod requires 5V.</li>
    </ol>
    <p><strong> </strong></p>
    <p>&nbsp;</p>
    <h4><strong>ARENA ANALYSIS</strong></h4>
    <hr />
    <p>&nbsp;</p>
    <h5><em><strong>Navigation Scheme/Algorithm</strong> </em></h5>
    <ul>
        <li>First the bot moves forward and checks if a door is present.</li>
        <li>If present the bot enters the room.</li>
        <li>Inside the room black line follower is used.</li>
        <li>It follows the line and checks for presence of fire.</li>
        <li>If detected, the mechanism drops the magnet and the bot makes a 180 degree turn.</li>
        <li>On exiting the room, wall following algorithm is used to reach the central point.</li>
        <li>The above steps are repeated till all four rooms are checked.</li>
    </ul>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <h4><strong>CONCLUSION</strong></h4>
    <hr />
    <p>&nbsp;</p>
    <p>Over the period of the project, we faced many difficulties. These included dropping the magnets correctly into the depostion slot to put out fires. The most difficult challenge we faced, however, was interfacing the white line sensor with the bot for detection of the fire leds.  We overcame these difficulties and completed this project, which can be used for fire fighting.</p>
    <p>&nbsp;</p>
    <hr />
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <h4><strong>CODE:</strong></h4>
    <p>#define F_CPU 14745600</p>
    <p>#include &lt;avr/io.h&gt;</p>
    <p>#include &lt;avr/interrupt.h&gt;</p>
    <p>#include &lt;util/delay.h&gt;</p>
    <p>&nbsp;</p>
    <p>#include &lt;math.h&gt; //included to support power function</p>
    <p>#include &#8220;lcd.h&#8221;</p>
    <p>&nbsp;</p>
    <p>void port_init();</p>
    <p>void timer5_init();</p>
    <p>void velocity(unsigned char, unsigned char);</p>
    <p>void motors_delay();</p>
    <p>&nbsp;</p>
    <p>unsigned char ADC_Conversion(unsigned char);</p>
    <p>int c=0,angle=0,LED=1;</p>
    <p>unsigned char ADC_Value;</p>
    <p>unsigned char flag = 0, fl=0,count=0;</p>
    <p>unsigned int sharp9 = 0,sharp11=0,sharp13=0;</p>
    <p>unsigned char Left_white_line = 0;</p>
    <p>unsigned char Center_white_line = 0;</p>
    <p>unsigned char Right_white_line = 0;</p>
    <p>volatile unsigned long int ShaftCountLeft = 0; //to keep track of left position encoder</p>
    <p>volatile unsigned long int ShaftCountRight = 0; //to keep track of right position encoder</p>
    <p>volatile unsigned int Degrees; //to accept angle in degrees for turning</p>
    <p>&nbsp;</p>
    <p>void timer1_init(void)</p>
    <p>{</p>
    <p>TCCR1B = 0x00; //stop</p>
    <p>TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with</p>
    <p>TCNT1L = 0x01;    //Counter low value to which OCR1xH value is to be compared with</p>
    <p>OCR1AH = 0x03;  //Output compare Register high value for servo 1</p>
    <p>OCR1AL = 0xFF;    //Output Compare Register low Value For servo 1</p>
    <p>OCR1BH = 0x03;  //Output compare Register high value for servo 2</p>
    <p>OCR1BL = 0xFF;    //Output Compare Register low Value For servo 2</p>
    <p>OCR1CH = 0x03;  //Output compare Register high value for servo 3</p>
    <p>OCR1CL = 0xFF;    //Output Compare Register low Value For servo 3</p>
    <p>ICR1H  = 0x03;</p>
    <p>ICR1L  = 0xFF;</p>
    <p>TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}</p>
    <p>For Overriding normal port functionality to OCRnA outputs.</p>
    <p>{WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/</p>
    <p>TCCR1C = 0x00;</p>
    <p>TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)</p>
    <p>}</p>
    <p>void servo1_pin_config (void)</p>
    <p>{</p>
    <p>DDRB  = DDRB | 0x20;  //making PORTB 5 pin output</p>
    <p>PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1</p>
    <p>}</p>
    <p>unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)</p>
    <p>{</p>
    <p>float distance;</p>
    <p>unsigned int distanceInt;</p>
    <p>distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));</p>
    <p>distanceInt = (int)distance;</p>
    <p>if(distanceInt&gt;800)</p>
    <p>{</p>
    <p>distanceInt=800;</p>
    <p>}</p>
    <p>return distanceInt;</p>
    <p>}</p>
    <p>void motion_pin_config (void)</p>
    <p>{</p>
    <p>DDRA = DDRA | 0x0F;</p>
    <p>PORTA = PORTA &amp; 0xF0;</p>
    <p>DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation</p>
    <p>PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//Function to configure INT4 (PORTE 4) pin as input for the left position encoder</p>
    <p>void left_encoder_pin_config (void)</p>
    <p>{</p>
    <p>DDRE  = DDRE &amp; 0xEF;  //Set the direction of the PORTE 4 pin as input</p>
    <p>PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//Function to configure INT5 (PORTE 5) pin as input for the right position encoder</p>
    <p>void right_encoder_pin_config (void)</p>
    <p>{</p>
    <p>DDRE  = DDRE &amp; 0xDF;  //Set the direction of the PORTE 4 pin as input</p>
    <p>PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//Function to initialize ports</p>
    <p>void port_init()</p>
    <p>{</p>
    <p>motion_pin_config(); //robot motion pins config</p>
    <p>left_encoder_pin_config(); //left encoder pin config</p>
    <p>right_encoder_pin_config(); //right encoder pin config</p>
    <p>lcd_port_config();</p>
    <p>adc_pin_config();</p>
    <p>motion_pin_config();</p>
    <p>servo1_pin_config();</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void left_position_encoder_interrupt_init (void) //Interrupt 4 enable</p>
    <p>{</p>
    <p>cli(); //Clears the global interrupt</p>
    <p>EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge</p>
    <p>EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder</p>
    <p>sei();   // Enables the global interrupt</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void right_position_encoder_interrupt_init (void) //Interrupt 5 enable</p>
    <p>{</p>
    <p>cli(); //Clears the global interrupt</p>
    <p>EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge</p>
    <p>EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder</p>
    <p>sei();   // Enables the global interrupt</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//ISR for right position encoder</p>
    <p>ISR(INT5_vect)</p>
    <p>{</p>
    <p>ShaftCountRight++;  //increment right shaft position count</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>//ISR for left position encoder</p>
    <p>ISR(INT4_vect)</p>
    <p>{</p>
    <p>ShaftCountLeft++;  //increment left shaft position count</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>//Function used for setting motor&#8217;s direction</p>
    <p>void motion_set (unsigned char Direction)</p>
    <p>{</p>
    <p>unsigned char PortARestore = 0;</p>
    <p>&nbsp;</p>
    <p>Direction &amp;= 0x0F;                               // removing upper nibbel for the protection</p>
    <p>PortARestore = PORTA;                       // reading the PORTA original status</p>
    <p>PortARestore &amp;= 0xF0;                        // making lower direction nibbel to 0</p>
    <p>PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status</p>
    <p>PORTA = PortARestore;                       // executing the command</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void forward (void) //both wheels forward</p>
    <p>{</p>
    <p>motion_set(0x06);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void back (void) //both wheels backward</p>
    <p>{</p>
    <p>motion_set(0x09);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void left (void) //Left wheel backward, Right wheel forward</p>
    <p>{</p>
    <p>motion_set(0x05);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void right (void) //Left wheel forward, Right wheel backward</p>
    <p>{</p>
    <p>motion_set(0x0A);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void soft_left (void) //Left wheel stationary, Right wheel forward</p>
    <p>{</p>
    <p>motion_set(0x04);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void soft_right (void) //Left wheel forward, Right wheel is stationary</p>
    <p>{</p>
    <p>motion_set(0x02);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void soft_left_2 (void) //Left wheel backward, right wheel stationary</p>
    <p>{</p>
    <p>motion_set(0x01);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void soft_right_2 (void) //Left wheel stationary, Right wheel backward</p>
    <p>{</p>
    <p>motion_set(0x08);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void stop (void)</p>
    <p>{</p>
    <p>motion_set(0x00);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>//Function used for turning robot by specified degrees</p>
    <p>void angle_rotate(unsigned int Degrees)</p>
    <p>{</p>
    <p>float ReqdShaftCount = 0;</p>
    <p>unsigned long int ReqdShaftCountInt = 0;</p>
    <p>&nbsp;</p>
    <p>ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count</p>
    <p>ReqdShaftCountInt = (unsigned int) ReqdShaftCount;</p>
    <p>ShaftCountRight = 0;</p>
    <p>ShaftCountLeft = 0;</p>
    <p>&nbsp;</p>
    <p>while (1)</p>
    <p>{</p>
    <p>if((ShaftCountRight &gt;= ReqdShaftCountInt) | (ShaftCountLeft &gt;= ReqdShaftCountInt))</p>
    <p>break;</p>
    <p>}</p>
    <p>stop(); //Stop robot</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//Function used for moving robot forward by specified distance</p>
    <p>&nbsp;</p>
    <p>void linear_distance_mm(unsigned int DistanceInMM)</p>
    <p>{</p>
    <p>float ReqdShaftCount = 0;</p>
    <p>unsigned long int ReqdShaftCountInt = 0;</p>
    <p>&nbsp;</p>
    <p>ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count</p>
    <p>ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;</p>
    <p>&nbsp;</p>
    <p>ShaftCountRight = 0;</p>
    <p>while(1)</p>
    <p>{</p>
    <p>if(ShaftCountRight &gt; ReqdShaftCountInt)</p>
    <p>{</p>
    <p>break;</p>
    <p>}</p>
    <p>}</p>
    <p>stop(); //Stop robot</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void forward_mm(unsigned int DistanceInMM)</p>
    <p>{</p>
    <p>forward();</p>
    <p>linear_distance_mm(DistanceInMM);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void back_mm(unsigned int DistanceInMM)</p>
    <p>{</p>
    <p>back();</p>
    <p>linear_distance_mm(DistanceInMM);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void left_degrees(unsigned int Degrees)</p>
    <p>{</p>
    <p>// 88 pulses for 360 degrees rotation 4.090 degrees per count</p>
    <p>left(); //Turn left</p>
    <p>angle_rotate(Degrees);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>void right_degrees(unsigned int Degrees)</p>
    <p>{</p>
    <p>// 88 pulses for 360 degrees rotation 4.090 degrees per count</p>
    <p>right(); //Turn right</p>
    <p>angle_rotate(Degrees);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>void soft_left_degrees(unsigned int Degrees)</p>
    <p>{</p>
    <p>// 176 pulses for 360 degrees rotation 2.045 degrees per count</p>
    <p>soft_left(); //Turn soft left</p>
    <p>Degrees=Degrees*2;</p>
    <p>angle_rotate(Degrees);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void soft_right_degrees(unsigned int Degrees)</p>
    <p>{</p>
    <p>// 176 pulses for 360 degrees rotation 2.045 degrees per count</p>
    <p>soft_right();  //Turn soft right</p>
    <p>Degrees=Degrees*2;</p>
    <p>angle_rotate(Degrees);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void soft_left_2_degrees(unsigned int Degrees)</p>
    <p>{</p>
    <p>// 176 pulses for 360 degrees rotation 2.045 degrees per count</p>
    <p>soft_left_2(); //Turn reverse soft left</p>
    <p>Degrees=Degrees*2;</p>
    <p>angle_rotate(Degrees);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void soft_right_2_degrees(unsigned int Degrees)</p>
    <p>{</p>
    <p>// 176 pulses for 360 degrees rotation 2.045 degrees per count</p>
    <p>soft_right_2();  //Turn reverse soft right</p>
    <p>Degrees=Degrees*2;</p>
    <p>angle_rotate(Degrees);</p>
    <p>}</p>
    <p>void servo_1(unsigned char degrees)</p>
    <p>{</p>
    <p>float PositionPanServo = 0;</p>
    <p>PositionPanServo = ((float)degrees / 1.86) + 35.0;</p>
    <p>OCR1AH = 0x00;</p>
    <p>OCR1AL = (unsigned char) PositionPanServo;</p>
    <p>}</p>
    <p>void servo_1_free (void) //makes servo 1 free rotating</p>
    <p>{</p>
    <p>OCR1AH = 0x03;</p>
    <p>OCR1AL = 0xFF; //Servo 1 off</p>
    <p>}</p>
    <p>//Function to initialize all the devices</p>
    <p>void init_devices_1()</p>
    <p>{</p>
    <p>cli(); //Clears the global interrupt</p>
    <p>port_init();  //Initializes all the ports</p>
    <p>left_position_encoder_interrupt_init();</p>
    <p>right_position_encoder_interrupt_init();</p>
    <p>sei();   // Enables the global interrupt</p>
    <p>&nbsp;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void init_devices_2()</p>
    <p>{</p>
    <p>cli(); //Clears the global interrupts</p>
    <p>port_init();</p>
    <p>adc_init();</p>
    <p>timer5_init();</p>
    <p>timer1_init();</p>
    <p>sei();   //Enables the global interrupts</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>//Function to configure LCD port</p>
    <p>void lcd_port_config (void)</p>
    <p>{</p>
    <p>DDRC = DDRC | 0xF7; //all the LCD pin&#8217;s direction set as output</p>
    <p>PORTC = PORTC &amp; 0x80; // all the LCD pins are set to logic 0 except PORTC 7</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//ADC pin configuration</p>
    <p>void adc_pin_config (void)</p>
    <p>{</p>
    <p>DDRF = 0x00;</p>
    <p>PORTF = 0x00;</p>
    <p>DDRK = 0x00;</p>
    <p>PORTK = 0x00;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>//Function to Initialize PORTS</p>
    <p>/*void port_init()</p>
    <p>{</p>
    <p>lcd_port_config();</p>
    <p>adc_pin_config();</p>
    <p>motion_pin_config();</p>
    <p>}*/</p>
    <p>&nbsp;</p>
    <p>// Timer 5 initialized in PWM mode for velocity control</p>
    <p>// Prescale:256</p>
    <p>// PWM 8bit fast, TOP=0x00FF</p>
    <p>// Timer Frequency:225.000Hz</p>
    <p>void timer5_init()</p>
    <p>{</p>
    <p>TCCR5B = 0x00;    //Stop</p>
    <p>TCNT5H = 0xFF;     //Counter higher 8-bit value to which OCR5xH value is compared with</p>
    <p>TCNT5L = 0x01;     //Counter lower 8-bit value to which OCR5xH value is compared with</p>
    <p>OCR5AH = 0x00;   //Output compare register high value for Left Motor</p>
    <p>OCR5AL = 0xFF;     //Output compare register low value for Left Motor</p>
    <p>OCR5BH = 0x00;   //Output compare register high value for Right Motor</p>
    <p>OCR5BL = 0xFF;     //Output compare register low value for Right Motor</p>
    <p>OCR5CH = 0x00;   //Output compare register high value for Motor C1</p>
    <p>OCR5CL = 0xFF;     //Output compare register low value for Motor C1</p>
    <p>TCCR5A = 0xA9;    /*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}</p>
    <p>For Overriding normal port functionality to OCRnA outputs.</p>
    <p>{WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/</p>
    <p>&nbsp;</p>
    <p>TCCR5B = 0x0B;    //WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void adc_init()</p>
    <p>{</p>
    <p>ADCSRA = 0x00;</p>
    <p>ADCSRB = 0x00;                    //MUX5 = 0</p>
    <p>ADMUX = 0x20;                    //Vref=5V external &#8212; ADLAR=1 &#8212; MUX4:0 = 0000</p>
    <p>ACSR = 0x80;</p>
    <p>ADCSRA = 0x86;                    //ADEN=1 &#8212; ADIE=1 &#8212; ADPS2:0 = 1 1 0</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//Function For ADC Conversion</p>
    <p>unsigned char ADC_Conversion(unsigned char Ch)</p>
    <p>{</p>
    <p>unsigned char a;</p>
    <p>if(Ch&gt;7)</p>
    <p>{</p>
    <p>ADCSRB = 0x08;</p>
    <p>}</p>
    <p>Ch = Ch &amp; 0x07;</p>
    <p>ADMUX= 0x20| Ch;</p>
    <p>ADCSRA = ADCSRA | 0x40;                  //Set start conversion bit</p>
    <p>while((ADCSRA&amp;0x10)==0);                //Wait for conversion to complete</p>
    <p>a=ADCH;</p>
    <p>ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it</p>
    <p>ADCSRB = 0x00;</p>
    <p>return a;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//Function To Print Sesor Values At Desired Row And Coloumn Location on LCD</p>
    <p>void print_sensor(char row, char coloumn,unsigned char channel)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>ADC_Value = ADC_Conversion(channel);</p>
    <p>lcd_print(row, coloumn, ADC_Value, 3);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//Function for velocity control</p>
    <p>void velocity (unsigned char left_motor, unsigned char right_motor)</p>
    <p>{</p>
    <p>OCR5AL = (unsigned char)left_motor;</p>
    <p>OCR5BL = (unsigned char)right_motor;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>/*void init_devices (void)</p>
    <p>{</p>
    <p>cli(); //Clears the global interrupts</p>
    <p>port_init();</p>
    <p>adc_init();</p>
    <p>timer5_init();</p>
    <p>sei();   //Enables the global interrupts</p>
    <p>}*/</p>
    <p>void A (void)</p>
    <p>{</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);          //Getting data of Right WL Sensor</p>
    <p>sharp11=ADC_Conversion(11);</p>
    <p>sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>//sharp9=ADC_Conversion(9);</p>
    <p>//sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>LED=ADC_Conversion(7);</p>
    <p>&nbsp;</p>
    <p>flag=0;</p>
    <p>&nbsp;</p>
    <p>print_sensor(1,1,3);             //Prints value of White Line Sensor1</p>
    <p>print_sensor(1,5,2);             //Prints Value of White Line Sensor2</p>
    <p>print_sensor(1,9,1);             //Prints Value of White Line Sensor3</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//             lcd_print(2,5,sharp11,3);</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&gt;0x10)//black</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(150,150);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Left_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Right_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&lt;0x10 &amp;&amp; Left_white_line&lt;0x10 &amp;&amp; Right_white_line&lt;0x10)</p>
    <p>{</p>
    <p>forward();</p>
    <p>&nbsp;</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>//if((Center_white_line&gt;0x10 &amp;&amp; Left_white_line&gt;0x10 &amp;&amp; c&gt;=2) || (Center_white_line&gt;0x10 &amp;&amp; Right_white_line&gt;0x10 &amp;&amp; c&gt;=2))</p>
    <p>//{</p>
    <p>if (LED&lt;0x20 &amp; sharp11&lt;275)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>stop();</p>
    <p>_delay_ms(750);</p>
    <p>angle+=45;</p>
    <p>servo_1(angle);</p>
    <p>_delay_ms(1000);</p>
    <p>//soft_right_degrees(89.4);</p>
    <p>stop();</p>
    <p>_delay_ms(1000);</p>
    <p>left_degrees(90);</p>
    <p>_delay_ms(750);</p>
    <p>&nbsp;</p>
    <p>c=0;</p>
    <p>break;</p>
    <p>}</p>
    <p>if(sharp11&lt;100)</p>
    <p>{</p>
    <p>stop();</p>
    <p>_delay_ms(1000);</p>
    <p>left_degrees(180);</p>
    <p>_delay_ms(750);</p>
    <p>break;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>//}</p>
    <p>if((Center_white_line&gt;0x10 &amp;&amp; Left_white_line&gt;0x10 &amp;&amp; c&lt;2) || (Center_white_line&gt;0x10 &amp;&amp; Right_white_line&gt;0x10 &amp;&amp; c&lt;2))</p>
    <p>{</p>
    <p>++c;</p>
    <p>_delay_ms(750);</p>
    <p>}</p>
    <p>}</p>
    <p>fl=0;</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);          //Getting data of Right WL Sensor</p>
    <p>sharp11=ADC_Conversion(11);</p>
    <p>sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>sharp9=ADC_Conversion(9);</p>
    <p>sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>&nbsp;</p>
    <p>flag=0;</p>
    <p>&nbsp;</p>
    <p>print_sensor(1,1,3);             //Prints value of White Line Sensor1</p>
    <p>print_sensor(1,5,2);             //Prints Value of White Line Sensor2</p>
    <p>print_sensor(1,9,1);             //Prints Value of White Line Sensor3</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>if(Center_white_line&gt;0x10)</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(150,150);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Left_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Right_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&lt;0x10 &amp;&amp; Left_white_line&lt;0x10 &amp;&amp; Right_white_line&lt;0x10)</p>
    <p>{</p>
    <p>forward();</p>
    <p>&nbsp;</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>if(sharp9&gt;700)</p>
    <p>fl=1;</p>
    <p>if(Center_white_line&gt;0x10 &amp;&amp; sharp11&gt;700 &amp;&amp; fl==1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>break;</p>
    <p>}</p>
    <p>}</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);          //Getting data of Right WL Sensor</p>
    <p>sharp11=ADC_Conversion(11);</p>
    <p>sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>//sharp9=ADC_Conversion(9);</p>
    <p>//sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>&nbsp;</p>
    <p>flag=0;</p>
    <p>&nbsp;</p>
    <p>print_sensor(1,1,3);             //Prints value of White Line Sensor1</p>
    <p>print_sensor(1,5,2);             //Prints Value of White Line Sensor2</p>
    <p>print_sensor(1,9,1);             //Prints Value of White Line Sensor3</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>if(Center_white_line&gt;0x10)</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(150,150);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Left_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Right_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&lt;0x10 &amp;&amp; Left_white_line&lt;0x10 &amp;&amp; Right_white_line&lt;0x10 &amp;&amp; sharp11&gt;400)</p>
    <p>{</p>
    <p>forward();</p>
    <p>&nbsp;</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&lt;0x10 &amp;&amp; Left_white_line&lt;0x10 &amp;&amp; Right_white_line&lt;0x10 &amp;&amp; sharp11&lt;=400)</p>
    <p>{</p>
    <p>break;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>}</p>
    <p>while (sharp11&gt;200)</p>
    <p>{</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>sharp11=ADC_Conversion(11);</p>
    <p>sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>forward();</p>
    <p>velocity(180,180);</p>
    <p>}</p>
    <p>soft_right_degrees(90);</p>
    <p>while(1)</p>
    <p>{</p>
    <p>sharp9=ADC_Conversion(9);</p>
    <p>sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>if (sharp9&gt;200)</p>
    <p>{</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>if (sharp9&lt;200)</p>
    <p>{</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>if (sharp9==200)</p>
    <p>{</p>
    <p>forward();</p>
    <p>velocity (255,255);</p>
    <p>}</p>
    <p>if (Center_white_line&gt;0x10 || Left_white_line&gt;0x10 || Right_white_line&gt;0x10)</p>
    <p>{</p>
    <p>break;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);          //Getting data of Right WL Sensor</p>
    <p>//sharp11=ADC_Conversion(11);</p>
    <p>//sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>//sharp9=ADC_Conversion(9);</p>
    <p>//sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>&nbsp;</p>
    <p>flag=0;</p>
    <p>&nbsp;</p>
    <p>print_sensor(1,1,3);             //Prints value of White Line Sensor1</p>
    <p>print_sensor(1,5,2);             //Prints Value of White Line Sensor2</p>
    <p>print_sensor(1,9,1);             //Prints Value of White Line Sensor3</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>if(Center_white_line&gt;0x10)</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(150,150);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Left_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Right_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&gt;0x10 &amp;&amp; Left_white_line&gt;0x10 &amp;&amp; Right_white_line&gt;0x10)</p>
    <p>{</p>
    <p>soft_left_degrees(92);</p>
    <p>_delay_ms(1000);</p>
    <p>stop();</p>
    <p>_delay_ms(1000);</p>
    <p>count++;</p>
    <p>break;</p>
    <p>}</p>
    <p>}</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>void B (void)</p>
    <p>{</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);          //Getting data of Right WL Sensor</p>
    <p>sharp11=ADC_Conversion(11);</p>
    <p>sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>sharp9=ADC_Conversion(9);</p>
    <p>sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>LED=ADC_Conversion(7);</p>
    <p>&nbsp;</p>
    <p>flag=0;</p>
    <p>&nbsp;</p>
    <p>print_sensor(1,1,3);             //Prints value of White Line Sensor1</p>
    <p>print_sensor(1,5,2);             //Prints Value of White Line Sensor2</p>
    <p>print_sensor(1,9,1);             //Prints Value of White Line Sensor3</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>if(Center_white_line&gt;0x10)</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(150,150);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Left_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Right_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&lt;0x10 &amp;&amp; Left_white_line&lt;0x10 &amp;&amp; Right_white_line&lt;0x10)</p>
    <p>{</p>
    <p>forward();</p>
    <p>&nbsp;</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>//if((Center_white_line&gt;0x10 &amp;&amp; Left_white_line&gt;0x10 &amp;&amp; c&gt;=2) || (Center_white_line&gt;0x10 &amp;&amp; Right_white_line&gt;0x10 &amp;&amp; c&gt;=2))</p>
    <p>//{</p>
    <p>if (LED&lt;0x20 &amp;&amp; sharp11&lt;275)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>stop();</p>
    <p>_delay_ms(750);</p>
    <p>angle+=45;</p>
    <p>servo_1(angle);</p>
    <p>_delay_ms(1000);</p>
    <p>//soft_left_degrees(89.3);</p>
    <p>stop();</p>
    <p>_delay(1000);</p>
    <p>right_degrees(90);</p>
    <p>_delay_ms(750);</p>
    <p>c=0;</p>
    <p>break;</p>
    <p>}</p>
    <p>if(sharp11&lt;100)</p>
    <p>{</p>
    <p>stop();</p>
    <p>_delay_ms(1000);</p>
    <p>right_degrees(180);</p>
    <p>_delay_ms(750);</p>
    <p>break;</p>
    <p>}</p>
    <p>//}</p>
    <p>if((Center_white_line&gt;0x10 &amp;&amp; Left_white_line&gt;0x10 &amp;&amp; c&lt;2) || (Center_white_line&gt;0x10 &amp;&amp; Right_white_line&gt;0x10 &amp;&amp; c&lt;2))</p>
    <p>{</p>
    <p>++c;</p>
    <p>_delay_ms(750);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>}</p>
    <p>fl=0;</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);          //Getting data of Right WL Sensor</p>
    <p>sharp11=ADC_Conversion(11);</p>
    <p>sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>sharp13=ADC_Conversion(13);</p>
    <p>sharp13=Sharp_GP2D12_estimation(sharp13);</p>
    <p>&nbsp;</p>
    <p>flag=0;</p>
    <p>&nbsp;</p>
    <p>print_sensor(1,1,3);             //Prints value of White Line Sensor1</p>
    <p>print_sensor(1,5,2);             //Prints Value of White Line Sensor2</p>
    <p>print_sensor(1,9,1);             //Prints Value of White Line Sensor3</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//             lcd_print(2,5,sharp11,3);</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&gt;0x10)//black</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(150,150);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Left_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Right_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&lt;0x10 &amp;&amp; Left_white_line&lt;0x10 &amp;&amp; Right_white_line&lt;0x10)</p>
    <p>{</p>
    <p>forward();</p>
    <p>&nbsp;</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>if(sharp13==800)</p>
    <p>fl=1;</p>
    <p>if(Center_white_line&gt;0x10 &amp;&amp; sharp11==800 &amp;&amp; fl==1)</p>
    <p>{</p>
    <p>break;</p>
    <p>}</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);          //Getting data of Right WL Sensor</p>
    <p>sharp11=ADC_Conversion(11);</p>
    <p>sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>//sharp9=ADC_Conversion(9);</p>
    <p>//sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>&nbsp;</p>
    <p>flag=0;</p>
    <p>&nbsp;</p>
    <p>print_sensor(1,1,3);             //Prints value of White Line Sensor1</p>
    <p>print_sensor(1,5,2);             //Prints Value of White Line Sensor2</p>
    <p>print_sensor(1,9,1);             //Prints Value of White Line Sensor3</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>if(Center_white_line&gt;0x10)</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(150,150);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Left_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Right_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&lt;0x10 &amp;&amp; Left_white_line&lt;0x10 &amp;&amp; Right_white_line&lt;0x10 &amp;&amp; sharp11&gt;400)</p>
    <p>{</p>
    <p>forward();</p>
    <p>&nbsp;</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&lt;0x10 &amp;&amp; Left_white_line&lt;0x10 &amp;&amp; Right_white_line&lt;0x10 &amp;&amp; sharp11&lt;=400)</p>
    <p>{</p>
    <p>break;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>}</p>
    <p>while (sharp11&gt;200)</p>
    <p>{</p>
    <p>sharp11=ADC_Conversion(11);</p>
    <p>sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>forward();</p>
    <p>velocity(130,130);</p>
    <p>}</p>
    <p>soft_right_degrees(90);</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>sharp9=ADC_Conversion(9);</p>
    <p>sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>if (sharp9&gt;200)</p>
    <p>{</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>if (sharp9&lt;200)</p>
    <p>{</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>if (sharp9==200)</p>
    <p>{</p>
    <p>forward();</p>
    <p>velocity (255,255);</p>
    <p>}</p>
    <p>if (Center_white_line&gt;0x10 || Left_white_line&gt;0x10 || Right_white_line&gt;0x10)</p>
    <p>{</p>
    <p>break;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>while(1)</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>Left_white_line = ADC_Conversion(3);             //Getting data of Left WL Sensor</p>
    <p>Center_white_line = ADC_Conversion(2);        //Getting data of Center WL Sensor</p>
    <p>Right_white_line = ADC_Conversion(1);          //Getting data of Right WL Sensor</p>
    <p>//sharp11=ADC_Conversion(11);</p>
    <p>//sharp11=Sharp_GP2D12_estimation(sharp11);</p>
    <p>//sharp9=ADC_Conversion(9);</p>
    <p>//sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>&nbsp;</p>
    <p>flag=0;</p>
    <p>&nbsp;</p>
    <p>print_sensor(1,1,3);             //Prints value of White Line Sensor1</p>
    <p>print_sensor(1,5,2);             //Prints Value of White Line Sensor2</p>
    <p>print_sensor(1,9,1);             //Prints Value of White Line Sensor3</p>
    <p>//lcd_print(2,1,sharp9,3);</p>
    <p>//lcd_print(2,5,sharp11,3);</p>
    <p>if(Center_white_line&gt;0x10)</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(150,150);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Left_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(130,50);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if((Right_white_line&lt;0x10) &amp;&amp; (flag==0))</p>
    <p>{</p>
    <p>flag=1;</p>
    <p>forward();</p>
    <p>velocity(50,130);</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>if(Center_white_line&gt;0x10 &amp;&amp; Left_white_line&gt;0x10 &amp;&amp; Right_white_line&gt;0x10)</p>
    <p>{</p>
    <p>soft_left_degrees(92);</p>
    <p>_delay_ms(1000);</p>
    <p>stop();</p>
    <p>_delay_ms(750);</p>
    <p>count++;</p>
    <p>break;</p>
    <p>}</p>
    <p>}</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>//Main Function</p>
    <p>int main()</p>
    <p>{</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>init_devices_1();</p>
    <p>init_devices_2();</p>
    <p>lcd_set_4bit();</p>
    <p>lcd_init();</p>
    <p>&nbsp;</p>
    <p>servo_1(0);</p>
    <p>_delay_ms(1000);</p>
    <p>forward_mm(195);</p>
    <p>while(count&lt;4)</p>
    <p>{</p>
    <p>c=0;</p>
    <p>&nbsp;</p>
    <p>forward_mm(270); //Moves robot forward 100mm</p>
    <p>stop();</p>
    <p>_delay_ms(750);</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>sharp9=ADC_Conversion(9);</p>
    <p>sharp9=Sharp_GP2D12_estimation(sharp9);</p>
    <p>&nbsp;</p>
    <p>/*forward_mm(30); //Moves robot forward 100mm</p>
    <p>stop();</p>
    <p>_delay_ms(750);*/</p>
    <p>&nbsp;</p>
    <p>if(sharp9&gt;200)</p>
    <p>{</p>
    <p>soft_left_degrees(83); //Rotate (soft turn) by 90 degrees</p>
    <p>stop();</p>
    <p>_delay_ms(750);</p>
    <p>A();</p>
    <p>}</p>
    <p>&nbsp;</p>
    <p>else</p>
    <p>{</p>
    <p>forward_mm(400); //Moves robot forward 100mm</p>
    <p>stop();</p>
    <p>_delay_ms(750);</p>
    <p>soft_left_degrees(83); //Rotate (soft turn) by 90 degrees</p>
    <p>stop();</p>
    <p>_delay_ms(750);</p>
    <p>B();</p>
    <p>}</p>
    <p>}</p>
    <p>DDRC = DDRC | 0x08;                          //Setting PORTC 3 as output</p>
    <p>PORTC = PORTC &amp; 0xF7;                     //Setting PORTC 3 logic low to turnoff buzzer</p>
    <p>unsigned char port_restore = 0;</p>
    <p>port_restore = PINC;</p>
    <p>port_restore = port_restore | 0x08;</p>
    <p>PORTC = port_restore;</p>
    <p>_delay_ms(1000);                                //delay</p>
    <p>port_restore = PINC;</p>
    <p>port_restore = port_restore &amp; 0xF7;</p>
    <p>PORTC = port_restore;</p>
    <p>_delay_ms(1000);                                //delay</p>

</div>

</body>
</html>